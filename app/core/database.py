
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from app.core.config import settings
# This is your database connection string (DSN).
# dialect+driver://username:password@host:port/database
# DATABASE_URL = "postgresql+psycopg2://santoshchandan:postgres@localhost:5432/fastapi"

DATABASE_URL = (
    f"postgresql://{settings.DATABASE_USERNAME}:"
    f"{settings.DATABASE_PASSWORD}@"
    f"{settings.DATABASE_HOST}:"
    f"{settings.DATABASE_PORT}/"
    f"{settings.DATABASE_NAME}"
)

#### Flow => engine → Session → Base → Model → DB


# Creates the connection engine that knows how to talk to your DB (PostgreSQL in this case).
# This is the core object that maintains DB connections.
# echo=True → Logs all SQL statements generated by SQLAlchemy (very useful for debugging).
engine = create_engine(DATABASE_URL, echo=True)

# Factory function that gives you a Session class (like a DB session/transaction handler).
# Builds a Session factory (think of it like a DB session generator).
# Every time you call SessionLocal(), you get a new Session object connected to your DB.
# autocommit=False → You must explicitly commit transactions (safe).
# autoflush=False → Changes won’t be auto-pushed to DB until commit (again, safer).
# bind=engine → This session factory will use the engine you created above.
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Creates a base class that your ORM models inherit from.
# By inheriting from Base, SQLAlchemy knows this is a table-mapped class.
# Creates a Base class from which all your ORM models will inherit (so SQLAlchemy knows how to map them to tables).
Base = declarative_base()


# Safely provide a database session to any endpoint.
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
